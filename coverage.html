
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bean: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sword-demon/vtool/bean/copier.go (0.0%)</option>
				
				<option value="file1">github.com/sword-demon/vtool/internal/bean/copier.go (64.7%)</option>
				
				<option value="file2">github.com/sword-demon/vtool/internal/list/arraylist.go (90.5%)</option>
				
				<option value="file3">github.com/sword-demon/vtool/internal/list/linkedlist.go (87.2%)</option>
				
				<option value="file4">github.com/sword-demon/vtool/internal/list/skiplist.go (94.7%)</option>
				
				<option value="file5">github.com/sword-demon/vtool/internal/maps/get.go (85.7%)</option>
				
				<option value="file6">github.com/sword-demon/vtool/internal/mapx/hashmap.go (87.9%)</option>
				
				<option value="file7">github.com/sword-demon/vtool/internal/mapx/linkedmap.go (91.5%)</option>
				
				<option value="file8">github.com/sword-demon/vtool/internal/mapx/treemap.go (88.1%)</option>
				
				<option value="file9">github.com/sword-demon/vtool/internal/queue/priorityqueue.go (100.0%)</option>
				
				<option value="file10">github.com/sword-demon/vtool/internal/queue/queue.go (100.0%)</option>
				
				<option value="file11">github.com/sword-demon/vtool/internal/set/hashset.go (90.9%)</option>
				
				<option value="file12">github.com/sword-demon/vtool/internal/set/sortedset.go (100.0%)</option>
				
				<option value="file13">github.com/sword-demon/vtool/internal/set/treeset.go (87.3%)</option>
				
				<option value="file14">github.com/sword-demon/vtool/internal/slice/add.go (100.0%)</option>
				
				<option value="file15">github.com/sword-demon/vtool/internal/slice/delete.go (100.0%)</option>
				
				<option value="file16">github.com/sword-demon/vtool/internal/slice/find.go (100.0%)</option>
				
				<option value="file17">github.com/sword-demon/vtool/internal/slice/map_reduce.go (100.0%)</option>
				
				<option value="file18">github.com/sword-demon/vtool/internal/slice/union.go (100.0%)</option>
				
				<option value="file19">github.com/sword-demon/vtool/list/arraylist.go (0.0%)</option>
				
				<option value="file20">github.com/sword-demon/vtool/list/linkedlist.go (0.0%)</option>
				
				<option value="file21">github.com/sword-demon/vtool/list/skiplist.go (0.0%)</option>
				
				<option value="file22">github.com/sword-demon/vtool/mapx/get.go (0.0%)</option>
				
				<option value="file23">github.com/sword-demon/vtool/mapx/hashmap.go (0.0%)</option>
				
				<option value="file24">github.com/sword-demon/vtool/mapx/linkedmap.go (0.0%)</option>
				
				<option value="file25">github.com/sword-demon/vtool/mapx/treemap.go (0.0%)</option>
				
				<option value="file26">github.com/sword-demon/vtool/queue/queue.go (0.0%)</option>
				
				<option value="file27">github.com/sword-demon/vtool/sets/hashset.go (0.0%)</option>
				
				<option value="file28">github.com/sword-demon/vtool/sets/sortedset.go (0.0%)</option>
				
				<option value="file29">github.com/sword-demon/vtool/sets/treeset.go (0.0%)</option>
				
				<option value="file30">github.com/sword-demon/vtool/slice/add.go (0.0%)</option>
				
				<option value="file31">github.com/sword-demon/vtool/slice/delete.go (0.0%)</option>
				
				<option value="file32">github.com/sword-demon/vtool/slice/find.go (0.0%)</option>
				
				<option value="file33">github.com/sword-demon/vtool/slice/map_reduce.go (0.0%)</option>
				
				<option value="file34">github.com/sword-demon/vtool/slice/union.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bean

import "github.com/sword-demon/vtool/internal/bean"

// Converter 类型转换函数类型
type Converter = bean.Converter

// Options 复制选项
type Options = bean.Options

// Copy 复制结构体
// src 源结构体指针，dst 目标结构体指针
func Copy(src, dst interface{}, opts ...Options) error <span class="cov0" title="0">{
        return bean.Copy(src, dst, opts...)
}</span>

// CopyWithoutNil 复制结构体，跳过nil指针
func CopyWithoutNil(src, dst interface{}) error <span class="cov0" title="0">{
        return bean.CopyWithoutNil(src, dst)
}</span>

// DeepCopy 深度复制结构体
func DeepCopy(src, dst interface{}) error <span class="cov0" title="0">{
        return bean.DeepCopy(src, dst)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package bean

import (
        "errors"
        "fmt"
        "reflect"
        "time"
)

// Converter 类型转换函数类型
type Converter func(srcValue reflect.Value, dstType reflect.Type) (reflect.Value, error)

// Options 复制选项
type Options struct {
        Converter    Converter
        IgnoreFields []string
        DeepCopy     bool
        IgnoreEmpty  bool
}

// 默认选项
var defaultOptions = Options{
        DeepCopy:    false,
        IgnoreEmpty: false,
        Converter:   nil,
}

// Copy 复制结构体
// src 源结构体指针，dst 目标结构体指针
func Copy(src, dst interface{}, opts ...Options) error <span class="cov8" title="1">{
        if src == nil || dst == nil </span><span class="cov8" title="1">{
                return errors.New("source and destination cannot be nil")
        }</span>

        // 合并选项
        <span class="cov8" title="1">options := defaultOptions
        if len(opts) &gt; 0 </span><span class="cov8" title="1">{
                options = opts[0]
        }</span>

        // 获取反射值
        <span class="cov8" title="1">srcVal, dstVal, err := validateAndGetValues(src, dst)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 执行复制
        <span class="cov8" title="1">return copyValue(srcVal, dstVal, options)</span>
}

// CopyWithoutNil 复制结构体，跳过nil指针
func CopyWithoutNil(src, dst interface{}) error <span class="cov0" title="0">{
        return Copy(src, dst, Options{
                DeepCopy:    true,
                IgnoreEmpty: true,
        })
}</span>

// DeepCopy 深度复制结构体
func DeepCopy(src, dst interface{}) error <span class="cov8" title="1">{
        return Copy(src, dst, Options{
                DeepCopy: true,
        })
}</span>

// validateAndGetValues 验证输入并获取反射值
func validateAndGetValues(src, dst interface{}) (reflect.Value, reflect.Value, error) <span class="cov8" title="1">{
        srcVal := reflect.ValueOf(src)
        dstVal := reflect.ValueOf(dst)

        // 检查指针
        if srcVal.Kind() != reflect.Ptr || dstVal.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                return reflect.Value{}, reflect.Value{}, errors.New("source and destination must be pointers")
        }</span>

        // 解引用
        <span class="cov8" title="1">for srcVal.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if srcVal.IsNil() </span><span class="cov0" title="0">{
                        return reflect.Value{}, reflect.Value{}, errors.New("source pointer is nil")
                }</span>
                <span class="cov8" title="1">srcVal = srcVal.Elem()</span>
        }

        <span class="cov8" title="1">for dstVal.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if dstVal.IsNil() </span><span class="cov0" title="0">{
                        // 创建目标对象
                        dstVal.Set(reflect.New(dstVal.Type().Elem()))
                }</span>
                <span class="cov8" title="1">dstVal = dstVal.Elem()</span>
        }

        // 检查类型
        <span class="cov8" title="1">if srcVal.Kind() != reflect.Struct || dstVal.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return reflect.Value{}, reflect.Value{}, errors.New("source and destination must be structs")
        }</span>

        <span class="cov8" title="1">return srcVal, dstVal, nil</span>
}

// copyValue 复制值
func copyValue(srcVal, dstVal reflect.Value, options Options) error <span class="cov8" title="1">{
        srcType := srcVal.Type()

        // 创建字段映射（字段名 -&gt; 字段信息）
        fieldMap := make(map[string]reflect.StructField)
        for i := 0; i &lt; srcType.NumField(); i++ </span><span class="cov8" title="1">{
                field := srcType.Field(i)
                // 跳过不可导出字段
                if field.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 跳过忽略字段
                <span class="cov8" title="1">if contains(options.IgnoreFields, field.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">fieldMap[field.Name] = field</span>
        }

        // 复制字段
        <span class="cov8" title="1">for i := 0; i &lt; dstVal.NumField(); i++ </span><span class="cov8" title="1">{
                dstField := dstVal.Type().Field(i)
                dstFieldValue := dstVal.Field(i)

                // 跳过不可导出字段
                if dstField.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 查找对应的源字段
                <span class="cov8" title="1">if srcField, ok := fieldMap[dstField.Name]; ok </span><span class="cov8" title="1">{
                        srcFieldValue := srcVal.FieldByIndex(srcField.Index)

                        // 检查是否可以设置
                        if !dstFieldValue.CanSet() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 检查是否忽略空值
                        <span class="cov8" title="1">if options.IgnoreEmpty &amp;&amp; isZeroValue(srcFieldValue) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // 执行复制
                        <span class="cov8" title="1">if err := copyField(srcFieldValue, dstFieldValue, options); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error copying field %s: %w", dstField.Name, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// copyField 复制单个字段
func copyField(srcVal, dstVal reflect.Value, options Options) error <span class="cov8" title="1">{
        // 如果类型相同，直接复制
        if srcVal.Type() == dstVal.Type() </span><span class="cov8" title="1">{
                // 深度复制
                if options.DeepCopy </span><span class="cov8" title="1">{
                        return deepCopyValue(srcVal, dstVal)
                }</span>
                <span class="cov8" title="1">dstVal.Set(srcVal)
                return nil</span>
        }

        // 使用转换器
        <span class="cov8" title="1">if options.Converter != nil </span><span class="cov8" title="1">{
                converted, err := options.Converter(srcVal, dstVal.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dstVal.Set(converted)
                return nil</span>
        }

        // 尝试类型转换
        <span class="cov8" title="1">return tryConvert(srcVal, dstVal)</span>
}

// deepCopyValue 深度复制值
func deepCopyValue(srcVal, dstVal reflect.Value) error <span class="cov8" title="1">{
        switch srcVal.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                if srcVal.IsNil() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if dstVal.IsNil() </span><span class="cov8" title="1">{
                        dstVal.Set(reflect.New(srcVal.Elem().Type()))
                }</span>
                <span class="cov8" title="1">return deepCopyValue(srcVal.Elem(), dstVal.Elem())</span>

        case reflect.Struct:<span class="cov8" title="1">
                for i := 0; i &lt; srcVal.NumField(); i++ </span><span class="cov8" title="1">{
                        if err := deepCopyValue(srcVal.Field(i), dstVal.Field(i)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>

        case reflect.Slice:<span class="cov0" title="0">
                dstVal.Set(reflect.MakeSlice(srcVal.Type(), srcVal.Len(), srcVal.Len()))
                for i := 0; i &lt; srcVal.Len(); i++ </span><span class="cov0" title="0">{
                        if err := deepCopyValue(srcVal.Index(i), dstVal.Index(i)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>

        case reflect.Map:<span class="cov0" title="0">
                dstVal.Set(reflect.MakeMap(srcVal.Type()))
                for _, key := range srcVal.MapKeys() </span><span class="cov0" title="0">{
                        newKey := reflect.New(key.Type()).Elem()
                        if err := deepCopyValue(key, newKey); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">newValue := reflect.New(srcVal.MapIndex(key).Type()).Elem()
                        if err := deepCopyValue(srcVal.MapIndex(key), newValue); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">dstVal.SetMapIndex(newKey, newValue)</span>
                }
                <span class="cov0" title="0">return nil</span>

        default:<span class="cov8" title="1">
                dstVal.Set(srcVal)
                return nil</span>
        }
}

// tryConvert 尝试类型转换
func tryConvert(srcVal, dstVal reflect.Value) error <span class="cov8" title="1">{
        // 数字类型转换
        if isNumeric(srcVal.Type()) &amp;&amp; isNumeric(dstVal.Type()) </span><span class="cov8" title="1">{
                return convertNumeric(srcVal, dstVal)
        }</span>

        // 字符串转换
        <span class="cov8" title="1">if srcVal.Type() == reflect.TypeOf(time.Time{}) &amp;&amp; dstVal.Type() == reflect.TypeOf("") </span><span class="cov8" title="1">{
                t := srcVal.Interface().(time.Time)
                dstVal.SetString(t.Format(time.RFC3339))
                return nil
        }</span>

        <span class="cov0" title="0">if srcVal.Type() == reflect.TypeOf("") &amp;&amp; dstVal.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                str := srcVal.String()
                t, err := time.Parse(time.RFC3339, str)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">dstVal.Set(reflect.ValueOf(t))
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cannot convert from %s to %s", srcVal.Type(), dstVal.Type())</span>
}

// isNumeric 检查是否为数字类型
func isNumeric(t reflect.Type) bool <span class="cov8" title="1">{
        switch t.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
                reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// convertNumeric 转换数字类型
func convertNumeric(srcVal, dstVal reflect.Value) error <span class="cov8" title="1">{
        var dstValue int64
        isFloat := false

        switch srcVal.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                dstValue = srcVal.Int()</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                dstValue = int64(srcVal.Uint())</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                isFloat = true</span>
        }

        <span class="cov8" title="1">switch dstVal.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                if isFloat </span><span class="cov0" title="0">{
                        dstVal.SetInt(int64(srcVal.Float()))
                }</span> else<span class="cov8" title="1"> {
                        dstVal.SetInt(dstValue)
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                if isFloat </span><span class="cov0" title="0">{
                        dstVal.SetUint(uint64(srcVal.Float()))
                }</span> else<span class="cov0" title="0"> {
                        dstVal.SetUint(uint64(dstValue))
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                if isFloat </span><span class="cov8" title="1">{
                        dstVal.SetFloat(srcVal.Float())
                }</span> else<span class="cov0" title="0"> {
                        dstVal.SetFloat(float64(dstValue))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isZeroValue 检查是否为零值
func isZeroValue(v reflect.Value) bool <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Bool:<span class="cov0" title="0">
                return !v.Bool()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return v.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return v.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return v.Float() == 0</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                return v.Complex() == 0</span>
        case reflect.Array:<span class="cov0" title="0">
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        if !isZeroValue(v.Index(i)) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                return v.IsNil()</span>
        case reflect.String:<span class="cov8" title="1">
                return v.Len() == 0</span>
        }
        <span class="cov0" title="0">return false</span>
}

// contains 检查切片是否包含元素
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package list

import (
        "cmp"
        "errors"
)

// ArrayList 动态数组实现，类似于Java的ArrayList
type ArrayList[T cmp.Ordered] struct {
        items    []T
        length   int
        capacity int
}

// NewArrayList 创建新的ArrayList
func NewArrayList[T cmp.Ordered]() *ArrayList[T] <span class="cov8" title="1">{
        return &amp;ArrayList[T]{
                items:    make([]T, 0, 10), // 默认初始容量10
                length:   0,
                capacity: 10,
        }
}</span>

// NewArrayListWithCapacity 创建指定初始容量的ArrayList
func NewArrayListWithCapacity[T cmp.Ordered](capacity int) *ArrayList[T] <span class="cov8" title="1">{
        if capacity &lt; 1 </span><span class="cov0" title="0">{
                capacity = 1
        }</span>
        <span class="cov8" title="1">return &amp;ArrayList[T]{
                items:    make([]T, 0, capacity),
                length:   0,
                capacity: capacity,
        }</span>
}

// Add 添加元素到列表末尾
func (l *ArrayList[T]) Add(value T) <span class="cov8" title="1">{
        l.Insert(l.length, value)
}</span>

// Insert 在指定位置插入元素
func (l *ArrayList[T]) Insert(index int, value T) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; l.length </span><span class="cov8" title="1">{
                return errors.New("index out of range")
        }</span>

        // 检查是否需要扩容
        <span class="cov8" title="1">if l.length &gt;= l.capacity </span><span class="cov8" title="1">{
                l.expand()
        }</span>

        // 使用append来插入元素，保持items的len和cap正确
        <span class="cov8" title="1">if index == l.length </span><span class="cov8" title="1">{
                // 插入到末尾
                l.items = append(l.items, value)
        }</span> else<span class="cov8" title="1"> {
                // 插入到中间
                l.items = append(l.items[:index+1], l.items[index:]...)
                l.items[index] = value
        }</span>

        <span class="cov8" title="1">l.length++
        return nil</span>
}

// Remove 删除指定位置的元素
func (l *ArrayList[T]) Remove(index int) error <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov8" title="1">{
                return errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov8" title="1">{
                return errors.New("index out of range")
        }</span>

        // 使用 append 来删除元素
        <span class="cov8" title="1">l.items = append(l.items[:index], l.items[index+1:]...)
        l.length--

        // 检查是否需要收缩容量
        l.maybeShrink()

        return nil</span>
}

// Get 获取指定位置的元素
func (l *ArrayList[T]) Get(index int) (T, error) <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">return l.items[index], nil</span>
}

// Set 设置指定位置的元素值
func (l *ArrayList[T]) Set(index int, value T) error <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov0" title="0">{
                return errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov0" title="0">{
                return errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">l.items[index] = value
        return nil</span>
}

// IndexOf 查找元素第一次出现的位置
func (l *ArrayList[T]) IndexOf(value T) int <span class="cov8" title="1">{
        for i := 0; i &lt; l.length; i++ </span><span class="cov8" title="1">{
                if l.items[i] == value </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Contains 检查元素是否存在
func (l *ArrayList[T]) Contains(value T) bool <span class="cov8" title="1">{
        return l.IndexOf(value) != -1
}</span>

// Size 返回列表长度
func (l *ArrayList[T]) Size() int <span class="cov8" title="1">{
        return l.length
}</span>

// IsEmpty 检查列表是否为空
func (l *ArrayList[T]) IsEmpty() bool <span class="cov8" title="1">{
        return l.length == 0
}</span>

// Clear 清空列表
func (l *ArrayList[T]) Clear() <span class="cov8" title="1">{
        l.items = l.items[:0] // 重置len，保留cap
        l.length = 0
}</span>

// ToSlice 转换为切片
func (l *ArrayList[T]) ToSlice() []T <span class="cov8" title="1">{
        result := make([]T, l.length)
        copy(result, l.items[:l.length])
        return result
}</span>

// Capacity 返回当前容量
func (l *ArrayList[T]) Capacity() int <span class="cov8" title="1">{
        return l.capacity
}</span>

// Trim 收缩容量以匹配当前大小
func (l *ArrayList[T]) Trim() <span class="cov8" title="1">{
        l.capacity = l.length
        l.items = l.items[:l.length]
}</span>

// expand 扩容（内部方法）
func (l *ArrayList[T]) expand() <span class="cov8" title="1">{
        // 扩容为当前容量的2倍
        newCapacity := l.capacity * 2
        newItems := make([]T, 0, newCapacity)
        // 复制现有元素
        newItems = append(newItems, l.items...)
        l.items = newItems
        l.capacity = newCapacity
}</span>

// maybeShrink 检查是否需要收缩容量（内部方法）
func (l *ArrayList[T]) maybeShrink() <span class="cov8" title="1">{
        // 当元素数量小于容量的1/4时，收缩容量
        if l.length &gt; 0 &amp;&amp; l.length &lt; l.capacity/4 </span><span class="cov8" title="1">{
                newCapacity := l.capacity / 2
                if newCapacity &lt; 10 </span><span class="cov8" title="1">{
                        newCapacity = 10 // 最小容量
                }</span>
                <span class="cov8" title="1">newItems := make([]T, 0, newCapacity)
                newItems = append(newItems, l.items...)
                l.items = newItems
                l.capacity = newCapacity</span>
        }
}

// EnsureCapacity 确保容量至少为指定大小
func (l *ArrayList[T]) EnsureCapacity(minCapacity int) <span class="cov8" title="1">{
        if minCapacity &gt; l.capacity </span><span class="cov8" title="1">{
                l.capacity = minCapacity
                newItems := make([]T, 0, l.capacity)
                newItems = append(newItems, l.items...)
                l.items = newItems
        }</span>
}

// RemoveValue 删除第一个匹配的元素（值匹配）
func (l *ArrayList[T]) RemoveValue(value T) bool <span class="cov8" title="1">{
        index := l.IndexOf(value)
        if index == -1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">l.Remove(index)
        return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package list

import (
        "cmp"
        "errors"
)

// Node 双向链表节点
type Node[T cmp.Ordered] struct {
        Value T
        Prev  *Node[T]
        Next  *Node[T]
}

// LinkedList 双向链表
type LinkedList[T cmp.Ordered] struct {
        head   *Node[T]
        tail   *Node[T]
        length int
}

// NewLinkedList 创建新的双向链表
func NewLinkedList[T cmp.Ordered]() *LinkedList[T] <span class="cov8" title="1">{
        return &amp;LinkedList[T]{}
}</span>

// Add 添加元素到链表末尾
func (l *LinkedList[T]) Add(value T) <span class="cov8" title="1">{
        l.Insert(l.length, value)
}</span>

// Insert 在指定位置插入元素
func (l *LinkedList[T]) Insert(index int, value T) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; l.length </span><span class="cov8" title="1">{
                return errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">newNode := &amp;Node[T]{Value: value}

        if l.length == 0 </span><span class="cov8" title="1">{
                // 空链表
                l.head = newNode
                l.tail = newNode
        }</span> else<span class="cov8" title="1"> if index == 0 </span><span class="cov8" title="1">{
                // 插入到头部
                newNode.Next = l.head
                l.head.Prev = newNode
                l.head = newNode
        }</span> else<span class="cov8" title="1"> if index == l.length </span><span class="cov8" title="1">{
                // 插入到尾部
                newNode.Prev = l.tail
                l.tail.Next = newNode
                l.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                // 插入到中间
                current := l.getNode(index)
                newNode.Prev = current.Prev
                newNode.Next = current
                current.Prev.Next = newNode
                current.Prev = newNode
        }</span>

        <span class="cov8" title="1">l.length++
        return nil</span>
}

// Remove 删除指定位置的元素
func (l *LinkedList[T]) Remove(index int) error <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov8" title="1">{
                return errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov8" title="1">{
                return errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">if l.length == 1 </span><span class="cov0" title="0">{
                // 只有一个元素
                l.head = nil
                l.tail = nil
        }</span> else<span class="cov8" title="1"> if index == 0 </span><span class="cov8" title="1">{
                // 删除头部
                l.head = l.head.Next
                l.head.Prev = nil
        }</span> else<span class="cov8" title="1"> if index == l.length-1 </span><span class="cov0" title="0">{
                // 删除尾部
                l.tail = l.tail.Prev
                l.tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                // 删除中间元素
                current := l.getNode(index)
                current.Prev.Next = current.Next
                current.Next.Prev = current.Prev
        }</span>

        <span class="cov8" title="1">l.length--
        return nil</span>
}

// Get 获取指定位置的元素
func (l *LinkedList[T]) Get(index int) (T, error) <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">node := l.getNode(index)
        return node.Value, nil</span>
}

// Set 设置指定位置的元素值
func (l *LinkedList[T]) Set(index int, value T) error <span class="cov8" title="1">{
        if l.length == 0 </span><span class="cov0" title="0">{
                return errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= l.length </span><span class="cov0" title="0">{
                return errors.New("index out of range")
        }</span>

        <span class="cov8" title="1">node := l.getNode(index)
        node.Value = value
        return nil</span>
}

// IndexOf 查找元素第一次出现的位置
func (l *LinkedList[T]) IndexOf(value T) int <span class="cov8" title="1">{
        current := l.head
        for i := 0; i &lt; l.length; i++ </span><span class="cov8" title="1">{
                if current.Value == value </span><span class="cov8" title="1">{
                        return i
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Contains 检查元素是否存在
func (l *LinkedList[T]) Contains(value T) bool <span class="cov8" title="1">{
        return l.IndexOf(value) != -1
}</span>

// Size 返回链表长度
func (l *LinkedList[T]) Size() int <span class="cov8" title="1">{
        return l.length
}</span>

// IsEmpty 检查链表是否为空
func (l *LinkedList[T]) IsEmpty() bool <span class="cov8" title="1">{
        return l.length == 0
}</span>

// Clear 清空链表
func (l *LinkedList[T]) Clear() <span class="cov8" title="1">{
        l.head = nil
        l.tail = nil
        l.length = 0
}</span>

// ToSlice 转换为切片
func (l *LinkedList[T]) ToSlice() []T <span class="cov8" title="1">{
        result := make([]T, l.length)
        current := l.head
        for i := 0; i &lt; l.length; i++ </span><span class="cov8" title="1">{
                result[i] = current.Value
                current = current.Next
        }</span>
        <span class="cov8" title="1">return result</span>
}

// FromSlice 从切片创建链表
func (l *LinkedList[T]) FromSlice(values []T) <span class="cov8" title="1">{
        l.Clear()
        for _, value := range values </span><span class="cov8" title="1">{
                l.Add(value)
        }</span>
}

// getNode 获取指定位置的节点（内部方法）
func (l *LinkedList[T]) getNode(index int) *Node[T] <span class="cov8" title="1">{
        var current *Node[T]
        if index &lt; l.length/2 </span><span class="cov8" title="1">{
                // 从头部开始遍历
                current = l.head
                for i := 0; i &lt; index; i++ </span><span class="cov0" title="0">{
                        current = current.Next
                }</span>
        } else<span class="cov8" title="1"> {
                // 从尾部开始遍历
                current = l.tail
                for i := l.length - 1; i &gt; index; i-- </span><span class="cov8" title="1">{
                        current = current.Prev
                }</span>
        }
        <span class="cov8" title="1">return current</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package list

import (
        "cmp"
        "errors"
        "math/rand"
        "time"
)

// SkipNode 跳表节点
type SkipNode[T cmp.Ordered] struct {
        Value T
        Next  []*SkipNode[T] // 每一层的后继节点指针
}

// SkipList 跳表
type SkipList[T cmp.Ordered] struct {
        head     *SkipNode[T]
        rand     *rand.Rand
        maxLevel int
        length   int
}

// NewSkipList 创建新的跳表
func NewSkipList[T cmp.Ordered]() *SkipList[T] <span class="cov8" title="1">{
        // 创建头节点，使用最大层数（实际使用时会动态调整）
        maxLevel := 16 // 最大16层
        head := &amp;SkipNode[T]{
                Value: *new(T), // 哨兵节点，零值
                Next:  make([]*SkipNode[T], maxLevel),
        }

        return &amp;SkipList[T]{
                head:     head,
                maxLevel: 0, // 从0层开始
                length:   0,
                rand:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }
}</span>

// Insert 插入元素
func (s *SkipList[T]) Insert(value T) <span class="cov8" title="1">{
        // 查找插入位置和更新路径
        update := make([]*SkipNode[T], s.maxLevel+1)
        current := s.head

        // 从最高层开始查找插入位置
        for level := s.maxLevel; level &gt;= 0; level-- </span><span class="cov8" title="1">{
                for current.Next[level] != nil &amp;&amp; current.Next[level].Value &lt; value </span><span class="cov8" title="1">{
                        current = current.Next[level]
                }</span>
                <span class="cov8" title="1">update[level] = current</span>
        }

        // 如果值已存在，不插入
        <span class="cov8" title="1">if current.Next[0] != nil &amp;&amp; current.Next[0].Value == value </span><span class="cov8" title="1">{
                return
        }</span>

        // 随机决定层数
        <span class="cov8" title="1">newLevel := s.randomLevel()

        // 确保update数组有足够的空间
        if newLevel &gt; s.maxLevel </span><span class="cov8" title="1">{
                // 重新分配update数组
                newUpdate := make([]*SkipNode[T], newLevel+1)
                copy(newUpdate, update)
                update = newUpdate

                for level := s.maxLevel + 1; level &lt;= newLevel; level++ </span><span class="cov8" title="1">{
                        update[level] = s.head
                }</span>
                <span class="cov8" title="1">s.maxLevel = newLevel</span>
        }

        // 创建新节点
        <span class="cov8" title="1">newNode := &amp;SkipNode[T]{
                Value: value,
                Next:  make([]*SkipNode[T], newLevel+1),
        }

        // 在每一层插入节点
        for level := 0; level &lt;= newLevel; level++ </span><span class="cov8" title="1">{
                newNode.Next[level] = update[level].Next[level]
                update[level].Next[level] = newNode
        }</span>

        <span class="cov8" title="1">s.length++</span>
}

// Search 查找元素
func (s *SkipList[T]) Search(value T) bool <span class="cov8" title="1">{
        current := s.head

        // 从最高层开始查找
        for level := s.maxLevel; level &gt;= 0; level-- </span><span class="cov8" title="1">{
                for current.Next[level] != nil &amp;&amp; current.Next[level].Value &lt; value </span><span class="cov8" title="1">{
                        current = current.Next[level]
                }</span>
        }

        // 检查下一个节点是否为目标值
        <span class="cov8" title="1">current = current.Next[0]
        return current != nil &amp;&amp; current.Value == value</span>
}

// Remove 删除元素
func (s *SkipList[T]) Remove(value T) bool <span class="cov8" title="1">{
        update := make([]*SkipNode[T], s.maxLevel+1)
        current := s.head

        // 查找要删除的节点
        for level := s.maxLevel; level &gt;= 0; level-- </span><span class="cov8" title="1">{
                for current.Next[level] != nil &amp;&amp; current.Next[level].Value &lt; value </span><span class="cov8" title="1">{
                        current = current.Next[level]
                }</span>
                <span class="cov8" title="1">update[level] = current</span>
        }

        <span class="cov8" title="1">current = current.Next[0]
        if current == nil || current.Value != value </span><span class="cov8" title="1">{
                return false // 未找到
        }</span>

        // 从每一层中删除节点
        <span class="cov8" title="1">for level := 0; level &lt;= s.maxLevel; level++ </span><span class="cov8" title="1">{
                if update[level].Next[level] != current </span><span class="cov8" title="1">{
                        break</span> // 已经不在当前层
                }
                <span class="cov8" title="1">update[level].Next[level] = current.Next[level]</span>
        }

        // 减少层数（如果最高层为空）
        <span class="cov8" title="1">for s.maxLevel &gt; 0 &amp;&amp; s.head.Next[s.maxLevel] == nil </span><span class="cov8" title="1">{
                s.maxLevel--
        }</span>

        <span class="cov8" title="1">s.length--
        return true</span>
}

// Contains 检查元素是否存在
func (s *SkipList[T]) Contains(value T) bool <span class="cov8" title="1">{
        return s.Search(value)
}</span>

// Size 返回跳表中的元素数量
func (s *SkipList[T]) Size() int <span class="cov8" title="1">{
        return s.length
}</span>

// IsEmpty 检查跳表是否为空
func (s *SkipList[T]) IsEmpty() bool <span class="cov8" title="1">{
        return s.length == 0
}</span>

// ToSlice 转换为切片（已排序）
func (s *SkipList[T]) ToSlice() []T <span class="cov8" title="1">{
        result := make([]T, s.length)
        current := s.head.Next[0]
        for i := 0; i &lt; s.length; i++ </span><span class="cov8" title="1">{
                result[i] = current.Value
                current = current.Next[0]
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Clear 清空跳表
func (s *SkipList[T]) Clear() <span class="cov8" title="1">{
        maxLevel := 16
        s.head = &amp;SkipNode[T]{
                Value: *new(T), // 零值
                Next:  make([]*SkipNode[T], maxLevel),
        }
        s.maxLevel = 0
        s.length = 0
}</span>

// Min 返回最小值
func (s *SkipList[T]) Min() (T, error) <span class="cov8" title="1">{
        if s.length == 0 </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">return s.head.Next[0].Value, nil</span>
}

// Max 返回最大值
func (s *SkipList[T]) Max() (T, error) <span class="cov8" title="1">{
        if s.length == 0 </span><span class="cov0" title="0">{
                var zero T
                return zero, errors.New("list is empty")
        }</span>
        <span class="cov8" title="1">current := s.head.Next[0]
        for current.Next[0] != nil </span><span class="cov8" title="1">{
                current = current.Next[0]
        }</span>
        <span class="cov8" title="1">return current.Value, nil</span>
}

// randomLevel 随机生成层数
func (s *SkipList[T]) randomLevel() int <span class="cov8" title="1">{
        level := 0
        // 50%的概率进入下一层
        for level &lt; 16 &amp;&amp; s.rand.Float64() &lt; 0.5 </span><span class="cov8" title="1">{
                level++
        }</span>
        <span class="cov8" title="1">return level</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package maps

// Get 获取map中指定key的值，如果key不存在返回零值
// 返回值表示key是否存在于map中
func Get[K comparable, V any](src map[K]V, key K) (V, bool) <span class="cov8" title="1">{
        val, exists := src[key]
        return val, exists
}</span>

// Set 设置map中key的值为value
func Set[K comparable, V any](src map[K]V, key K, value V) <span class="cov0" title="0">{
        src[key] = value
}</span>

// Delete 删除map中指定的key
func Delete[K comparable, V any](src map[K]V, key K) <span class="cov0" title="0">{
        delete(src, key)
}</span>

// Has 检查map中是否包含指定的key
func Has[K comparable, V any](src map[K]V, key K) bool <span class="cov8" title="1">{
        _, exists := src[key]
        return exists
}</span>

// Keys 返回map中所有key的切片
func Keys[K comparable, V any](src map[K]V) []K <span class="cov8" title="1">{
        keys := make([]K, 0, len(src))
        for k := range src </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// Values 返回map中所有value的切片
func Values[K comparable, V any](src map[K]V) []V <span class="cov8" title="1">{
        values := make([]V, 0, len(src))
        for _, v := range src </span><span class="cov8" title="1">{
                values = append(values, v)
        }</span>
        <span class="cov8" title="1">return values</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package mapx

// HashMap 基于Go内置map实现的增强版映射
// 提供可预测的迭代顺序
type HashMap[K comparable, V any] struct {
        items map[K]V
        keys  []K // 维护插入顺序
}

// NewHashMap 创建新的HashMap
func NewHashMap[K comparable, V any]() *HashMap[K, V] <span class="cov8" title="1">{
        return &amp;HashMap[K, V]{
                items: make(map[K]V),
                keys:  make([]K, 0),
        }
}</span>

// Put 添加或更新键值对
func (m *HashMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        if _, exists := m.items[key]; !exists </span><span class="cov8" title="1">{
                // 新键，添加到keys列表
                m.keys = append(m.keys, key)
        }</span>
        <span class="cov8" title="1">m.items[key] = value</span>
}

// Get 获取值
func (m *HashMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        val, exists := m.items[key]
        return val, exists
}</span>

// Remove 删除键值对
func (m *HashMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        if _, exists := m.items[key]; exists </span><span class="cov8" title="1">{
                delete(m.items, key)
                // 从keys列表中移除
                for i, k := range m.keys </span><span class="cov8" title="1">{
                        if k == key </span><span class="cov8" title="1">{
                                m.keys = append(m.keys[:i], m.keys[i+1:]...)
                                break</span>
                        }
                }
        }
}

// Contains 检查键是否存在
func (m *HashMap[K, V]) Contains(key K) bool <span class="cov8" title="1">{
        _, exists := m.items[key]
        return exists
}</span>

// Size 返回键值对数量
func (m *HashMap[K, V]) Size() int <span class="cov8" title="1">{
        return len(m.items)
}</span>

// IsEmpty 检查是否为空
func (m *HashMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.items) == 0
}</span>

// Clear 清空映射
func (m *HashMap[K, V]) Clear() <span class="cov8" title="1">{
        m.items = make(map[K]V)
        m.keys = m.keys[:0]
}</span>

// Keys 返回所有键（按插入顺序）
func (m *HashMap[K, V]) Keys() []K <span class="cov8" title="1">{
        result := make([]K, len(m.keys))
        copy(result, m.keys)
        return result
}</span>

// Values 返回所有值（按插入顺序）
func (m *HashMap[K, V]) Values() []V <span class="cov8" title="1">{
        result := make([]V, 0, len(m.items))
        for _, key := range m.keys </span><span class="cov8" title="1">{
                result = append(result, m.items[key])
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ToMap 转换为Go内置map
func (m *HashMap[K, V]) ToMap() map[K]V <span class="cov0" title="0">{
        result := make(map[K]V, len(m.items))
        for k, v := range m.items </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Entries 返回所有键值对（按插入顺序）
func (m *HashMap[K, V]) Entries() []struct {
        K K
        V V
} <span class="cov8" title="1">{
        result := make([]struct {
                K K
                V V
        }, 0, len(m.items))
        for _, key := range m.keys </span><span class="cov8" title="1">{
                result = append(result, struct {
                        K K
                        V V
                }{K: key, V: m.items[key]})
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package mapx

// LinkedNode 链表节点
type LinkedNode[K comparable, V any] struct {
        Key   K
        Value V
        Prev  *LinkedNode[K, V]
        Next  *LinkedNode[K, V]
}

// LinkedMap 保持插入顺序的映射
type LinkedMap[K comparable, V any] struct {
        items  map[K]*LinkedNode[K, V]
        head   *LinkedNode[K, V]
        tail   *LinkedNode[K, V]
        length int
}

// NewLinkedMap 创建新的LinkedMap
func NewLinkedMap[K comparable, V any]() *LinkedMap[K, V] <span class="cov8" title="1">{
        return &amp;LinkedMap[K, V]{
                items:  make(map[K]*LinkedNode[K, V]),
                head:   nil,
                tail:   nil,
                length: 0,
        }
}</span>

// Put 添加或更新键值对
func (lm *LinkedMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        if node, exists := lm.items[key]; exists </span><span class="cov8" title="1">{
                // 键已存在，更新值并移到尾部
                node.Value = value
                if lm.tail != node </span><span class="cov8" title="1">{
                        lm.moveToTail(node)
                }</span>
        } else<span class="cov8" title="1"> {
                // 新键，创建新节点并加到尾部
                newNode := &amp;LinkedNode[K, V]{
                        Key:   key,
                        Value: value,
                }
                lm.items[key] = newNode
                lm.addToTail(newNode)
                lm.length++
        }</span>
}

// Get 获取值
func (lm *LinkedMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        if node, exists := lm.items[key]; exists </span><span class="cov8" title="1">{
                return node.Value, true
        }</span>
        <span class="cov0" title="0">var zero V
        return zero, false</span>
}

// Remove 删除键值对
func (lm *LinkedMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        if node, exists := lm.items[key]; exists </span><span class="cov8" title="1">{
                lm.removeNode(node)
                delete(lm.items, key)
                lm.length--
        }</span>
}

// Contains 检查键是否存在
func (lm *LinkedMap[K, V]) Contains(key K) bool <span class="cov8" title="1">{
        _, exists := lm.items[key]
        return exists
}</span>

// Size 返回键值对数量
func (lm *LinkedMap[K, V]) Size() int <span class="cov8" title="1">{
        return lm.length
}</span>

// IsEmpty 检查是否为空
func (lm *LinkedMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return lm.length == 0
}</span>

// Clear 清空映射
func (lm *LinkedMap[K, V]) Clear() <span class="cov8" title="1">{
        lm.items = make(map[K]*LinkedNode[K, V])
        lm.head = nil
        lm.tail = nil
        lm.length = 0
}</span>

// Keys 返回所有键（按插入顺序）
func (lm *LinkedMap[K, V]) Keys() []K <span class="cov8" title="1">{
        keys := make([]K, 0, lm.length)
        current := lm.head
        for current != nil </span><span class="cov8" title="1">{
                keys = append(keys, current.Key)
                current = current.Next
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// Values 返回所有值（按插入顺序）
func (lm *LinkedMap[K, V]) Values() []V <span class="cov8" title="1">{
        values := make([]V, 0, lm.length)
        current := lm.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.Value)
                current = current.Next
        }</span>
        <span class="cov8" title="1">return values</span>
}

// Entries 返回所有键值对（按插入顺序）
func (lm *LinkedMap[K, V]) Entries() []struct {
        K K
        V V
} <span class="cov8" title="1">{
        entries := make([]struct {
                K K
                V V
        }, 0, lm.length)
        current := lm.head
        for current != nil </span><span class="cov8" title="1">{
                entries = append(entries, struct {
                        K K
                        V V
                }{K: current.Key, V: current.Value})
                current = current.Next
        }</span>
        <span class="cov8" title="1">return entries</span>
}

// First 返回第一个键值对
func (lm *LinkedMap[K, V]) First() (K, V, bool) <span class="cov8" title="1">{
        if lm.head == nil </span><span class="cov8" title="1">{
                var zeroK K
                var zeroV V
                return zeroK, zeroV, false
        }</span>
        <span class="cov8" title="1">return lm.head.Key, lm.head.Value, true</span>
}

// Last 返回最后一个键值对
func (lm *LinkedMap[K, V]) Last() (K, V, bool) <span class="cov8" title="1">{
        if lm.tail == nil </span><span class="cov8" title="1">{
                var zeroK K
                var zeroV V
                return zeroK, zeroV, false
        }</span>
        <span class="cov8" title="1">return lm.tail.Key, lm.tail.Value, true</span>
}

// ToMap 转换为Go内置map
func (lm *LinkedMap[K, V]) ToMap() map[K]V <span class="cov0" title="0">{
        result := make(map[K]V, lm.length)
        for k, node := range lm.items </span><span class="cov0" title="0">{
                result[k] = node.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// addToTail 添加节点到尾部
func (lm *LinkedMap[K, V]) addToTail(node *LinkedNode[K, V]) <span class="cov8" title="1">{
        if lm.tail == nil </span><span class="cov8" title="1">{
                // 链表为空
                lm.head = node
                lm.tail = node
        }</span> else<span class="cov8" title="1"> {
                // 添加到尾部
                node.Prev = lm.tail
                node.Next = nil
                lm.tail.Next = node
                lm.tail = node
        }</span>
}

// removeNode 移除节点
func (lm *LinkedMap[K, V]) removeNode(node *LinkedNode[K, V]) <span class="cov8" title="1">{
        if node.Prev != nil </span><span class="cov8" title="1">{
                node.Prev.Next = node.Next
        }</span> else<span class="cov8" title="1"> {
                // 是头节点
                lm.head = node.Next
        }</span>

        <span class="cov8" title="1">if node.Next != nil </span><span class="cov8" title="1">{
                node.Next.Prev = node.Prev
        }</span> else<span class="cov8" title="1"> {
                // 是尾节点
                lm.tail = node.Prev
        }</span>
}

// moveToTail 将节点移到尾部
func (lm *LinkedMap[K, V]) moveToTail(node *LinkedNode[K, V]) <span class="cov8" title="1">{
        if lm.tail == node </span><span class="cov0" title="0">{
                return // 已经是尾节点
        }</span>

        // 从当前位置移除
        <span class="cov8" title="1">if node.Prev != nil </span><span class="cov8" title="1">{
                node.Prev.Next = node.Next
        }</span> else<span class="cov8" title="1"> {
                // 是头节点
                lm.head = node.Next
        }</span>
        <span class="cov8" title="1">if node.Next != nil </span><span class="cov8" title="1">{
                node.Next.Prev = node.Prev
        }</span>

        // 添加到尾部
        <span class="cov8" title="1">node.Prev = lm.tail
        node.Next = nil
        if lm.tail != nil </span><span class="cov8" title="1">{
                lm.tail.Next = node
        }</span>
        <span class="cov8" title="1">lm.tail = node</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mapx

import (
        "cmp"
        "errors"
)

// TreeNode 树节点
type TreeNode[K cmp.Ordered, V any] struct {
        Key    K
        Value  V
        Left   *TreeNode[K, V]
        Right  *TreeNode[K, V]
        Parent *TreeNode[K, V]
        Color  bool // true = Red, false = Black
}

// TreeMap 有序映射，基于二叉搜索树
type TreeMap[K cmp.Ordered, V any] struct {
        root   *TreeNode[K, V]
        length int
}

// NewTreeMap 创建新的TreeMap
func NewTreeMap[K cmp.Ordered, V any]() *TreeMap[K, V] <span class="cov8" title="1">{
        return &amp;TreeMap[K, V]{
                root:   nil,
                length: 0,
        }
}</span>

// Put 添加或更新键值对
func (tm *TreeMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        tm.root = tm.insert(tm.root, key, value, nil)
        tm.length++
}</span>

// Get 获取值
func (tm *TreeMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        node := tm.search(tm.root, key)
        if node == nil </span><span class="cov0" title="0">{
                var zero V
                return zero, false
        }</span>
        <span class="cov8" title="1">return node.Value, true</span>
}

// Remove 删除键
func (tm *TreeMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        deleted := tm.delete(tm.root, key)
        if deleted </span><span class="cov8" title="1">{
                tm.length--
        }</span>
}

// Contains 检查键是否存在
func (tm *TreeMap[K, V]) Contains(key K) bool <span class="cov8" title="1">{
        return tm.search(tm.root, key) != nil
}</span>

// Size 返回键值对数量
func (tm *TreeMap[K, V]) Size() int <span class="cov8" title="1">{
        return tm.length
}</span>

// IsEmpty 检查是否为空
func (tm *TreeMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return tm.length == 0
}</span>

// Clear 清空映射
func (tm *TreeMap[K, V]) Clear() <span class="cov8" title="1">{
        tm.root = nil
        tm.length = 0
}</span>

// Keys 返回所有键（按排序顺序）
func (tm *TreeMap[K, V]) Keys() []K <span class="cov8" title="1">{
        var keys []K
        tm.inOrderTraversal(tm.root, &amp;keys)
        return keys
}</span>

// Values 返回所有值（按排序顺序）
func (tm *TreeMap[K, V]) Values() []V <span class="cov8" title="1">{
        var values []V
        tm.inOrderTraversalValues(tm.root, &amp;values)
        return values
}</span>

// Entries 返回所有键值对（按排序顺序）
func (tm *TreeMap[K, V]) Entries() []struct {
        K K
        V V
} <span class="cov8" title="1">{
        var entries []struct {
                K K
                V V
        }
        tm.inOrderTraversalEntries(tm.root, &amp;entries)
        return entries
}</span>

// Min 返回最小键
func (tm *TreeMap[K, V]) Min() (K, error) <span class="cov8" title="1">{
        if tm.root == nil </span><span class="cov8" title="1">{
                var zero K
                return zero, errors.New("tree map is empty")
        }</span>
        <span class="cov8" title="1">node := tm.min(tm.root)
        return node.Key, nil</span>
}

// Max 返回最大键
func (tm *TreeMap[K, V]) Max() (K, error) <span class="cov8" title="1">{
        if tm.root == nil </span><span class="cov8" title="1">{
                var zero K
                return zero, errors.New("tree map is empty")
        }</span>
        <span class="cov8" title="1">node := tm.max(tm.root)
        return node.Key, nil</span>
}

// insert 插入节点
func (tm *TreeMap[K, V]) insert(node *TreeNode[K, V], key K, value V, parent *TreeNode[K, V]) *TreeNode[K, V] <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return &amp;TreeNode[K, V]{
                        Key:    key,
                        Value:  value,
                        Parent: parent,
                        Color:  true, // 新节点默认为红色
                }
        }</span>

        <span class="cov8" title="1">if key &lt; node.Key </span><span class="cov8" title="1">{
                node.Left = tm.insert(node.Left, key, value, node)
        }</span> else<span class="cov8" title="1"> if key &gt; node.Key </span><span class="cov8" title="1">{
                node.Right = tm.insert(node.Right, key, value, node)
        }</span> else<span class="cov8" title="1"> {
                // 键已存在，更新值
                node.Value = value
                tm.length-- // 抵消后面的length++
        }</span>

        <span class="cov8" title="1">return node</span>
}

// search 搜索节点
func (tm *TreeMap[K, V]) search(node *TreeNode[K, V], key K) *TreeNode[K, V] <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if key &lt; node.Key </span><span class="cov8" title="1">{
                return tm.search(node.Left, key)
        }</span> else<span class="cov8" title="1"> if key &gt; node.Key </span><span class="cov8" title="1">{
                return tm.search(node.Right, key)
        }</span> else<span class="cov8" title="1"> {
                return node
        }</span>
}

// delete 删除节点
func (tm *TreeMap[K, V]) delete(node *TreeNode[K, V], key K) bool <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if key &lt; node.Key </span><span class="cov8" title="1">{
                return tm.delete(node.Left, key)
        }</span> else<span class="cov8" title="1"> if key &gt; node.Key </span><span class="cov8" title="1">{
                return tm.delete(node.Right, key)
        }</span> else<span class="cov8" title="1"> {
                // 找到要删除的节点
                if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov8" title="1">{
                        // 叶子节点
                        if node.Parent != nil </span><span class="cov8" title="1">{
                                if node.Parent.Left == node </span><span class="cov0" title="0">{
                                        node.Parent.Left = nil
                                }</span> else<span class="cov8" title="1"> {
                                        node.Parent.Right = nil
                                }</span>
                        }
                        <span class="cov8" title="1">return true</span>
                } else<span class="cov8" title="1"> if node.Left == nil </span><span class="cov8" title="1">{
                        // 只有右子节点
                        if node.Parent != nil </span><span class="cov8" title="1">{
                                if node.Parent.Left == node </span><span class="cov0" title="0">{
                                        node.Parent.Left = node.Right
                                }</span> else<span class="cov8" title="1"> {
                                        node.Parent.Right = node.Right
                                }</span>
                        }
                        <span class="cov8" title="1">node.Right.Parent = node.Parent
                        return true</span>
                } else<span class="cov8" title="1"> if node.Right == nil </span><span class="cov0" title="0">{
                        // 只有左子节点
                        if node.Parent != nil </span><span class="cov0" title="0">{
                                if node.Parent.Left == node </span><span class="cov0" title="0">{
                                        node.Parent.Left = node.Left
                                }</span> else<span class="cov0" title="0"> {
                                        node.Parent.Right = node.Left
                                }</span>
                        }
                        <span class="cov0" title="0">node.Left.Parent = node.Parent
                        return true</span>
                } else<span class="cov8" title="1"> {
                        // 有两个子节点，找到后继节点
                        successor := tm.min(node.Right)
                        node.Key = successor.Key
                        node.Value = successor.Value
                        return tm.delete(node.Right, successor.Key)
                }</span>
        }
}

// min 找到最小节点
func (tm *TreeMap[K, V]) min(node *TreeNode[K, V]) *TreeNode[K, V] <span class="cov8" title="1">{
        current := node
        for current.Left != nil </span><span class="cov8" title="1">{
                current = current.Left
        }</span>
        <span class="cov8" title="1">return current</span>
}

// max 找到最大节点
func (tm *TreeMap[K, V]) max(node *TreeNode[K, V]) *TreeNode[K, V] <span class="cov8" title="1">{
        current := node
        for current.Right != nil </span><span class="cov0" title="0">{
                current = current.Right
        }</span>
        <span class="cov8" title="1">return current</span>
}

// inOrderTraversal 中序遍历收集键
func (tm *TreeMap[K, V]) inOrderTraversal(node *TreeNode[K, V], keys *[]K) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                tm.inOrderTraversal(node.Left, keys)
                *keys = append(*keys, node.Key)
                tm.inOrderTraversal(node.Right, keys)
        }</span>
}

// inOrderTraversalValues 中序遍历收集值
func (tm *TreeMap[K, V]) inOrderTraversalValues(node *TreeNode[K, V], values *[]V) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                tm.inOrderTraversalValues(node.Left, values)
                *values = append(*values, node.Value)
                tm.inOrderTraversalValues(node.Right, values)
        }</span>
}

// inOrderTraversalEntries 中序遍历收集键值对
func (tm *TreeMap[K, V]) inOrderTraversalEntries(node *TreeNode[K, V], entries *[]struct {
        K K
        V V
},
) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                tm.inOrderTraversalEntries(node.Left, entries)
                *entries = append(*entries, struct {
                        K K
                        V V
                }{K: node.Key, V: node.Value})
                tm.inOrderTraversalEntries(node.Right, entries)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package queue

import "errors"

// PriorityItem 优先级队列中的元素
type PriorityItem[T any] struct {
        Value    T
        Priority int // 优先级，数值越小优先级越高
}

// PriorityQueue 优先级队列 - 基于最小堆实现
type PriorityQueue[T any] struct {
        items []PriorityItem[T]
}

// NewPriorityQueue 创建新的优先级队列
func NewPriorityQueue[T any]() *PriorityQueue[T] <span class="cov8" title="1">{
        return &amp;PriorityQueue[T]{
                items: make([]PriorityItem[T], 0),
        }
}</span>

// Enqueue 入队 - 添加元素和优先级
func (pq *PriorityQueue[T]) Enqueue(value T, priority int) <span class="cov8" title="1">{
        item := PriorityItem[T]{
                Value:    value,
                Priority: priority,
        }
        pq.items = append(pq.items, item)
        pq.siftUp(len(pq.items) - 1)
}</span>

// Dequeue 出队 - 移除并返回优先级最高的元素
func (pq *PriorityQueue[T]) Dequeue() (T, int, error) <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                var zero T
                return zero, 0, errors.New("priority queue is empty")
        }</span>

        // 取出根节点（优先级最高的）
        <span class="cov8" title="1">item := pq.items[0]
        value := item.Value
        priority := item.Priority

        // 将最后一个元素移到根节点
        lastIndex := len(pq.items) - 1
        pq.items[0] = pq.items[lastIndex]
        pq.items = pq.items[:lastIndex]

        // 如果还有元素，重新堆化
        if len(pq.items) &gt; 0 </span><span class="cov8" title="1">{
                pq.siftDown(0)
        }</span>

        <span class="cov8" title="1">return value, priority, nil</span>
}

// Peek 查看优先级最高的元素
func (pq *PriorityQueue[T]) Peek() (T, int, error) <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                var zero T
                return zero, 0, errors.New("priority queue is empty")
        }</span>

        <span class="cov8" title="1">return pq.items[0].Value, pq.items[0].Priority, nil</span>
}

// Size 返回队列中的元素数量
func (pq *PriorityQueue[T]) Size() int <span class="cov8" title="1">{
        return len(pq.items)
}</span>

// IsEmpty 检查队列是否为空
func (pq *PriorityQueue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(pq.items) == 0
}</span>

// Clear 清空队列
func (pq *PriorityQueue[T]) Clear() <span class="cov8" title="1">{
        pq.items = pq.items[:0]
}</span>

// ToSlice 转换为切片（按优先级排序）
func (pq *PriorityQueue[T]) ToSlice() []PriorityItem[T] <span class="cov8" title="1">{
        result := make([]PriorityItem[T], len(pq.items))
        copy(result, pq.items)
        return result
}</span>

// siftUp 向上堆化（插入时使用）
func (pq *PriorityQueue[T]) siftUp(index int) <span class="cov8" title="1">{
        for index &gt; 0 </span><span class="cov8" title="1">{
                parent := (index - 1) / 2

                // 如果当前元素优先级更高（数值更小），交换
                if pq.items[index].Priority &lt; pq.items[parent].Priority </span><span class="cov8" title="1">{
                        pq.items[index], pq.items[parent] = pq.items[parent], pq.items[index]
                        index = parent
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
}

// siftDown 向下堆化（删除时使用）
func (pq *PriorityQueue[T]) siftDown(index int) <span class="cov8" title="1">{
        length := len(pq.items)
        for </span><span class="cov8" title="1">{
                left := 2*index + 1
                right := 2*index + 2
                smallest := index

                // 找到子节点中优先级更高的
                if left &lt; length &amp;&amp; pq.items[left].Priority &lt; pq.items[smallest].Priority </span><span class="cov8" title="1">{
                        smallest = left
                }</span>
                <span class="cov8" title="1">if right &lt; length &amp;&amp; pq.items[right].Priority &lt; pq.items[smallest].Priority </span><span class="cov8" title="1">{
                        smallest = right
                }</span>

                // 如果根节点已经是优先级最高的，停止
                <span class="cov8" title="1">if smallest == index </span><span class="cov8" title="1">{
                        break</span>
                }

                // 交换元素
                <span class="cov8" title="1">pq.items[index], pq.items[smallest] = pq.items[smallest], pq.items[index]
                index = smallest</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package queue

import (
        "errors"
)

// Queue 普通队列 - FIFO (先进先出)
type Queue[T any] struct {
        items []T
}

// NewQueue 创建新的队列
func NewQueue[T any]() *Queue[T] <span class="cov8" title="1">{
        return &amp;Queue[T]{
                items: make([]T, 0),
        }
}</span>

// Enqueue 入队 - 添加元素到队列尾部
func (q *Queue[T]) Enqueue(value T) <span class="cov8" title="1">{
        q.items = append(q.items, value)
}</span>

// Dequeue 出队 - 从队列头部移除并返回元素
// 如果队列为空，返回零值和错误
func (q *Queue[T]) Dequeue() (T, error) <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                var zero T
                return zero, errors.New("queue is empty")
        }</span>

        <span class="cov8" title="1">value := q.items[0]
        q.items = q.items[1:]
        return value, nil</span>
}

// Peek 查看队首元素 - 返回队首元素但不移除
// 如果队列为空，返回零值和错误
func (q *Queue[T]) Peek() (T, error) <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                var zero T
                return zero, errors.New("queue is empty")
        }</span>

        <span class="cov8" title="1">return q.items[0], nil</span>
}

// Size 返回队列中的元素数量
func (q *Queue[T]) Size() int <span class="cov8" title="1">{
        return len(q.items)
}</span>

// IsEmpty 检查队列是否为空
func (q *Queue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(q.items) == 0
}</span>

// Clear 清空队列
func (q *Queue[T]) Clear() <span class="cov8" title="1">{
        q.items = q.items[:0]
}</span>

// ToSlice 转换为切片
func (q *Queue[T]) ToSlice() []T <span class="cov8" title="1">{
        result := make([]T, len(q.items))
        copy(result, q.items)
        return result
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package set

// HashSet 基于map实现的哈希集合
type HashSet[T comparable] struct {
        items map[T]struct{} // 使用空结构体节省内存
}

// NewHashSet 创建新的HashSet
func NewHashSet[T comparable]() *HashSet[T] <span class="cov8" title="1">{
        return &amp;HashSet[T]{
                items: make(map[T]struct{}),
        }
}</span>

// Add 添加元素到集合
func (s *HashSet[T]) Add(item T) <span class="cov8" title="1">{
        s.items[item] = struct{}{}
}</span>

// Remove 从集合中删除元素
func (s *HashSet[T]) Remove(item T) <span class="cov8" title="1">{
        delete(s.items, item)
}</span>

// Contains 检查元素是否在集合中
func (s *HashSet[T]) Contains(item T) bool <span class="cov8" title="1">{
        _, exists := s.items[item]
        return exists
}</span>

// Size 返回集合大小
func (s *HashSet[T]) Size() int <span class="cov8" title="1">{
        return len(s.items)
}</span>

// IsEmpty 检查集合是否为空
func (s *HashSet[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.items) == 0
}</span>

// Clear 清空集合
func (s *HashSet[T]) Clear() <span class="cov8" title="1">{
        for k := range s.items </span><span class="cov8" title="1">{
                delete(s.items, k)
        }</span>
}

// ToSlice 返回集合的所有元素为切片
func (s *HashSet[T]) ToSlice() []T <span class="cov8" title="1">{
        items := make([]T, 0, len(s.items))
        for item := range s.items </span><span class="cov8" title="1">{
                items = append(items, item)
        }</span>
        <span class="cov8" title="1">return items</span>
}

// Union 返回两个集合的并集
func (s *HashSet[T]) Union(other *HashSet[T]) *HashSet[T] <span class="cov8" title="1">{
        result := NewHashSet[T]()

        // 添加当前集合的元素
        for item := range s.items </span><span class="cov8" title="1">{
                result.Add(item)
        }</span>

        // 添加另一个集合的元素
        <span class="cov8" title="1">for item := range other.items </span><span class="cov8" title="1">{
                result.Add(item)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Intersect 返回两个集合的交集
func (s *HashSet[T]) Intersect(other *HashSet[T]) *HashSet[T] <span class="cov8" title="1">{
        result := NewHashSet[T]()

        // 遍历较小的集合
        if s.Size() &lt; other.Size() </span><span class="cov0" title="0">{
                for item := range s.items </span><span class="cov0" title="0">{
                        if other.Contains(item) </span><span class="cov0" title="0">{
                                result.Add(item)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for item := range other.items </span><span class="cov8" title="1">{
                        if s.Contains(item) </span><span class="cov8" title="1">{
                                result.Add(item)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// Difference 返回两个集合的差集 (s - other)
func (s *HashSet[T]) Difference(other *HashSet[T]) *HashSet[T] <span class="cov8" title="1">{
        result := NewHashSet[T]()

        for item := range s.items </span><span class="cov8" title="1">{
                if !other.Contains(item) </span><span class="cov8" title="1">{
                        result.Add(item)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package set

import (
        "cmp"
        "sort"
)

// SortedSet 排序并去重切片中的元素
// 返回新的有序切片
// T必须是可比较且可排序的类型
func SortedSet[T cmp.Ordered](src []T) []T <span class="cov8" title="1">{
        if len(src) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        // 复制切片避免修改原数据
        <span class="cov8" title="1">result := make([]T, len(src))
        copy(result, src)

        // 排序
        sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i] &lt; result[j]
        }</span>)

        // 去重
        <span class="cov8" title="1">unique := make([]T, 0, len(result))
        for i, item := range result </span><span class="cov8" title="1">{
                if i == 0 || item != result[i-1] </span><span class="cov8" title="1">{
                        unique = append(unique, item)
                }</span>
        }

        <span class="cov8" title="1">return unique</span>
}

// SortedSetDesc 降序排序并去重
func SortedSetDesc[T cmp.Ordered](src []T) []T <span class="cov8" title="1">{
        if len(src) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        // 复制切片避免修改原数据
        <span class="cov8" title="1">result := make([]T, len(src))
        copy(result, src)

        // 降序排序
        sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i] &gt; result[j]
        }</span>)

        // 去重
        <span class="cov8" title="1">unique := make([]T, 0, len(result))
        for i, item := range result </span><span class="cov8" title="1">{
                if i == 0 || item != result[i-1] </span><span class="cov8" title="1">{
                        unique = append(unique, item)
                }</span>
        }

        <span class="cov8" title="1">return unique</span>
}

// Unique 仅去重，保持原有顺序
func Unique[T comparable](src []T) []T <span class="cov8" title="1">{
        if len(src) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        <span class="cov8" title="1">seen := make(map[T]bool)
        result := make([]T, 0, len(src))

        for _, item := range src </span><span class="cov8" title="1">{
                if !seen[item] </span><span class="cov8" title="1">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package set

import (
        "cmp"
        "sort"
)

// TreeSet 基于排序切片实现的有序集合
// T必须是可比较且可排序的类型
type TreeSet[T cmp.Ordered] struct {
        items []T
}

// NewTreeSet 创建新的TreeSet
func NewTreeSet[T cmp.Ordered]() *TreeSet[T] <span class="cov8" title="1">{
        return &amp;TreeSet[T]{
                items: make([]T, 0),
        }
}</span>

// Add 添加元素到集合，自动保持有序
func (s *TreeSet[T]) Add(item T) <span class="cov8" title="1">{
        // 如果元素已存在，不添加
        if s.Contains(item) </span><span class="cov8" title="1">{
                return
        }</span>

        // 插入元素并保持有序
        <span class="cov8" title="1">s.items = append(s.items, item)
        sort.Slice(s.items, func(i, j int) bool </span><span class="cov8" title="1">{
                return s.items[i] &lt; s.items[j]
        }</span>)
}

// Remove 从集合中删除元素
func (s *TreeSet[T]) Remove(item T) <span class="cov8" title="1">{
        index := sort.Search(len(s.items), func(i int) bool </span><span class="cov8" title="1">{
                return s.items[i] &gt;= item
        }</span>)

        // 找到精确匹配的元素
        <span class="cov8" title="1">if index &lt; len(s.items) &amp;&amp; s.items[index] == item </span><span class="cov8" title="1">{
                s.items = append(s.items[:index], s.items[index+1:]...)
        }</span>
}

// Contains 检查元素是否在集合中
func (s *TreeSet[T]) Contains(item T) bool <span class="cov8" title="1">{
        index := sort.Search(len(s.items), func(i int) bool </span><span class="cov8" title="1">{
                return s.items[i] &gt;= item
        }</span>)

        <span class="cov8" title="1">return index &lt; len(s.items) &amp;&amp; s.items[index] == item</span>
}

// Size 返回集合大小
func (s *TreeSet[T]) Size() int <span class="cov8" title="1">{
        return len(s.items)
}</span>

// IsEmpty 检查集合是否为空
func (s *TreeSet[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.items) == 0
}</span>

// Clear 清空集合
func (s *TreeSet[T]) Clear() <span class="cov8" title="1">{
        s.items = s.items[:0]
}</span>

// ToSlice 返回集合的所有元素为切片（已排序）
func (s *TreeSet[T]) ToSlice() []T <span class="cov8" title="1">{
        result := make([]T, len(s.items))
        copy(result, s.items)
        return result
}</span>

// Union 返回两个集合的并集
func (s *TreeSet[T]) Union(other *TreeSet[T]) *TreeSet[T] <span class="cov8" title="1">{
        result := NewTreeSet[T]()

        // 合并两个有序切片
        i, j := 0, 0
        for i &lt; len(s.items) &amp;&amp; j &lt; len(other.items) </span><span class="cov8" title="1">{
                if s.items[i] &lt; other.items[j] </span><span class="cov8" title="1">{
                        result.Add(s.items[i])
                        i++
                }</span> else<span class="cov8" title="1"> if s.items[i] &gt; other.items[j] </span><span class="cov0" title="0">{
                        result.Add(other.items[j])
                        j++
                }</span> else<span class="cov8" title="1"> {
                        // 元素相等，只添加一次
                        result.Add(s.items[i])
                        i++
                        j++
                }</span>
        }

        // 添加剩余元素
        <span class="cov8" title="1">for i &lt; len(s.items) </span><span class="cov0" title="0">{
                result.Add(s.items[i])
                i++
        }</span>
        <span class="cov8" title="1">for j &lt; len(other.items) </span><span class="cov8" title="1">{
                result.Add(other.items[j])
                j++
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Intersect 返回两个集合的交集
func (s *TreeSet[T]) Intersect(other *TreeSet[T]) *TreeSet[T] <span class="cov8" title="1">{
        result := NewTreeSet[T]()

        // 双指针遍历两个有序切片
        i, j := 0, 0
        for i &lt; len(s.items) &amp;&amp; j &lt; len(other.items) </span><span class="cov8" title="1">{
                if s.items[i] &lt; other.items[j] </span><span class="cov8" title="1">{
                        i++
                }</span> else<span class="cov8" title="1"> if s.items[i] &gt; other.items[j] </span><span class="cov0" title="0">{
                        j++
                }</span> else<span class="cov8" title="1"> {
                        // 元素相等，加入结果
                        result.Add(s.items[i])
                        i++
                        j++
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Difference 返回两个集合的差集 (s - other)
func (s *TreeSet[T]) Difference(other *TreeSet[T]) *TreeSet[T] <span class="cov8" title="1">{
        result := NewTreeSet[T]()

        // 双指针遍历
        i, j := 0, 0
        for i &lt; len(s.items) &amp;&amp; j &lt; len(other.items) </span><span class="cov8" title="1">{
                if s.items[i] &lt; other.items[j] </span><span class="cov8" title="1">{
                        result.Add(s.items[i])
                        i++
                }</span> else<span class="cov8" title="1"> if s.items[i] &gt; other.items[j] </span><span class="cov0" title="0">{
                        j++
                }</span> else<span class="cov8" title="1"> {
                        // 元素相等，跳过
                        i++
                        j++
                }</span>
        }

        // 添加s中剩余的元素
        <span class="cov8" title="1">for i &lt; len(s.items) </span><span class="cov0" title="0">{
                result.Add(s.items[i])
                i++
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package slice

import "errors"

func Add[T any](src []T, element T, index int) ([]T, error) <span class="cov8" title="1">{
        length := len(src)
        if index &lt; 0 || index &gt; length </span><span class="cov8" title="1">{
                return nil, errors.New("index is out of range")
        }</span>

        // 先将src扩展一个元素
        <span class="cov8" title="1">var zeroValue T
        src = append(src, zeroValue)
        for i := len(src) - 1; i &gt; index; i-- </span><span class="cov8" title="1">{
                if i-1 &gt;= 0 </span><span class="cov8" title="1">{
                        src[i] = src[i-1]
                }</span>
        }
        <span class="cov8" title="1">src[index] = element
        return src, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package slice

import "errors"

// Delete 删除index位置的元素
// index 范围在 [0, len(src)-1]
func Delete[T any](src []T, index int) ([]T, error) <span class="cov8" title="1">{
        length := len(src)
        if index &lt; 0 || index &gt;= length </span><span class="cov8" title="1">{
                return nil, errors.New("index is out of range")
        }</span>

        // 从index开始，所有元素向前移动一位
        <span class="cov8" title="1">for i := index; i &lt; length-1; i++ </span><span class="cov8" title="1">{
                src[i] = src[i+1]
        }</span>
        // 去掉最后一个元素
        <span class="cov8" title="1">return src[:length-1], nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package slice

// Find 查找第一个满足条件的元素
// predicate 是一个函数，接受元素并返回bool
// 返回找到的元素索引和值，如果没找到返回-1
func Find[T any](src []T, predicate func(T) bool) (int, T, bool) <span class="cov8" title="1">{
        for i, item := range src </span><span class="cov8" title="1">{
                if predicate(item) </span><span class="cov8" title="1">{
                        return i, item, true
                }</span>
        }
        <span class="cov8" title="1">var zeroValue T
        return -1, zeroValue, false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package slice

// Map 将每个元素映射为新值，返回新的切片
// mapper 是一个函数，接受原元素并返回新元素
func Map[T any, R any](src []T, mapper func(T) R) []R <span class="cov8" title="1">{
        result := make([]R, len(src))
        for i, item := range src </span><span class="cov8" title="1">{
                result[i] = mapper(item)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Reduce 将切片的所有元素聚合为一个值
// reducer 是一个函数，接受累计值和当前元素，返回新的累计值
// initial 是初始累计值
func Reduce[T any, R any](src []T, reducer func(R, T) R, initial R) R <span class="cov8" title="1">{
        result := initial
        for _, item := range src </span><span class="cov8" title="1">{
                result = reducer(result, item)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Filter 过滤元素，返回满足条件的新切片
// predicate 是一个函数，接受元素并返回bool
func Filter[T any](src []T, predicate func(T) bool) []T <span class="cov8" title="1">{
        var result []T
        for _, item := range src </span><span class="cov8" title="1">{
                if predicate(item) </span><span class="cov8" title="1">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package slice

// Union 求两个切片的并集，返回去重的结果
// 使用map来去重，保持元素的原始顺序
func Union[T comparable](src1, src2 []T) []T <span class="cov8" title="1">{
        // 如果两个切片都为空，返回空切片
        if len(src1) == 0 &amp;&amp; len(src2) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        <span class="cov8" title="1">seen := make(map[T]bool)
        var result []T

        // 添加第一个切片的元素
        for _, item := range src1 </span><span class="cov8" title="1">{
                if !seen[item] </span><span class="cov8" title="1">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }

        // 添加第二个切片的元素，去重
        <span class="cov8" title="1">for _, item := range src2 </span><span class="cov8" title="1">{
                if !seen[item] </span><span class="cov8" title="1">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package list

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/list"
)

// ArrayList 动态数组
type ArrayList[T cmp.Ordered] = list.ArrayList[T]

// NewArrayList 创建新的ArrayList
func NewArrayList[T cmp.Ordered]() *ArrayList[T] <span class="cov0" title="0">{
        return list.NewArrayList[T]()
}</span>

// NewArrayListWithCapacity 创建指定初始容量的ArrayList
func NewArrayListWithCapacity[T cmp.Ordered](capacity int) *ArrayList[T] <span class="cov0" title="0">{
        return list.NewArrayListWithCapacity[T](capacity)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package list

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/list"
)

// LinkedList 双向链表
type LinkedList[T cmp.Ordered] = list.LinkedList[T]

// NewLinkedList 创建新的双向链表
func NewLinkedList[T cmp.Ordered]() *LinkedList[T] <span class="cov0" title="0">{
        return list.NewLinkedList[T]()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package list

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/list"
)

// SkipList 跳表
type SkipList[T cmp.Ordered] = list.SkipList[T]

// NewSkipList 创建新的跳表
func NewSkipList[T cmp.Ordered]() *SkipList[T] <span class="cov0" title="0">{
        return list.NewSkipList[T]()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package mapx

import "github.com/sword-demon/vtool/internal/maps"

// Get 获取map中指定key的值
func Get[K comparable, V any](src map[K]V, key K) (V, bool) <span class="cov0" title="0">{
        val, exists := maps.Get(src, key)
        return val, exists
}</span>

// Set 设置map中key的值为value
func Set[K comparable, V any](src map[K]V, key K, value V) <span class="cov0" title="0">{
        maps.Set(src, key, value)
}</span>

// Delete 删除map中指定的key
func Delete[K comparable, V any](src map[K]V, key K) <span class="cov0" title="0">{
        maps.Delete(src, key)
}</span>

// Has 检查map中是否包含指定的key
func Has[K comparable, V any](src map[K]V, key K) bool <span class="cov0" title="0">{
        return maps.Has(src, key)
}</span>

// Keys 返回map中所有key的切片
func Keys[K comparable, V any](src map[K]V) []K <span class="cov0" title="0">{
        return maps.Keys(src)
}</span>

// Values 返回map中所有value的切片
func Values[K comparable, V any](src map[K]V) []V <span class="cov0" title="0">{
        return maps.Values(src)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package mapx

import "github.com/sword-demon/vtool/internal/mapx"

// HashMap 基于Go内置map实现的增强版映射
type HashMap[K comparable, V any] = mapx.HashMap[K, V]

// NewHashMap 创建新的HashMap
func NewHashMap[K comparable, V any]() *HashMap[K, V] <span class="cov0" title="0">{
        return mapx.NewHashMap[K, V]()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package mapx

import "github.com/sword-demon/vtool/internal/mapx"

// LinkedNode 链表节点
type LinkedNode[K comparable, V any] = mapx.LinkedNode[K, V]

// LinkedMap 保持插入顺序的映射
type LinkedMap[K comparable, V any] = mapx.LinkedMap[K, V]

// NewLinkedMap 创建新的LinkedMap
func NewLinkedMap[K comparable, V any]() *LinkedMap[K, V] <span class="cov0" title="0">{
        return mapx.NewLinkedMap[K, V]()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package mapx

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/mapx"
)

// TreeNode 树节点
type TreeNode[K cmp.Ordered, V any] = mapx.TreeNode[K, V]

// TreeMap 有序映射，基于二叉搜索树
type TreeMap[K cmp.Ordered, V any] = mapx.TreeMap[K, V]

// NewTreeMap 创建新的TreeMap
func NewTreeMap[K cmp.Ordered, V any]() *TreeMap[K, V] <span class="cov0" title="0">{
        return mapx.NewTreeMap[K, V]()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package queue

import "github.com/sword-demon/vtool/internal/queue"

// Queue 普通队列 - FIFO (先进先出)
type Queue[T any] = queue.Queue[T]

// NewQueue 创建新的队列
func NewQueue[T any]() *Queue[T] <span class="cov0" title="0">{
        return queue.NewQueue[T]()
}</span>

// PriorityItem 优先级队列中的元素
type PriorityItem[T any] = queue.PriorityItem[T]

// PriorityQueue 优先级队列
type PriorityQueue[T any] = queue.PriorityQueue[T]

// NewPriorityQueue 创建新的优先级队列
func NewPriorityQueue[T any]() *PriorityQueue[T] <span class="cov0" title="0">{
        return queue.NewPriorityQueue[T]()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package sets

import "github.com/sword-demon/vtool/internal/set"

// HashSet 基于map实现的哈希集合
type HashSet[T comparable] = set.HashSet[T]

// NewHashSet 创建新的HashSet
func NewHashSet[T comparable]() *HashSet[T] <span class="cov0" title="0">{
        return set.NewHashSet[T]()
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package sets

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/set"
)

// SortedSet 排序并去重切片中的元素
func SortedSet[T cmp.Ordered](src []T) []T <span class="cov0" title="0">{
        return set.SortedSet(src)
}</span>

// SortedSetDesc 降序排序并去重
func SortedSetDesc[T cmp.Ordered](src []T) []T <span class="cov0" title="0">{
        return set.SortedSetDesc(src)
}</span>

// Unique 仅去重，保持原有顺序
func Unique[T comparable](src []T) []T <span class="cov0" title="0">{
        return set.Unique(src)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package sets

import (
        "cmp"

        "github.com/sword-demon/vtool/internal/set"
)

// TreeSet 基于排序切片实现的有序集合
type TreeSet[T cmp.Ordered] = set.TreeSet[T]

// NewTreeSet 创建新的TreeSet
func NewTreeSet[T cmp.Ordered]() *TreeSet[T] <span class="cov0" title="0">{
        return set.NewTreeSet[T]()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package slice

import "github.com/sword-demon/vtool/internal/slice"

// Add 在index处添加元素
// index 范围在 [0, len(src)]
// 如果index == len(src) 则表示往末尾添加元素
func Add[Src any](src []Src, element Src, index int) ([]Src, error) <span class="cov0" title="0">{
        res, err := slice.Add[Src](src, element, index)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package slice

import "github.com/sword-demon/vtool/internal/slice"

// Delete 在index处删除元素
// index 范围在 [0, len(src)-1]
func Delete[Src any](src []Src, index int) ([]Src, error) <span class="cov0" title="0">{
        res, err := slice.Delete[Src](src, index)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package slice

import "github.com/sword-demon/vtool/internal/slice"

// Find 查找第一个满足条件的元素
// predicate 是一个函数，接受元素并返回bool
// 返回找到的元素索引和值，如果没找到返回-1
func Find[Src any](src []Src, predicate func(Src) bool) (int, Src, bool) <span class="cov0" title="0">{
        index, val, found := slice.Find(src, predicate)
        return index, val, found
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package slice

import "github.com/sword-demon/vtool/internal/slice"

// Map 将每个元素映射为新值，返回新的切片
func Map[Src any, Dst any](src []Src, mapper func(Src) Dst) []Dst <span class="cov0" title="0">{
        return slice.Map(src, mapper)
}</span>

// Reduce 将切片的所有元素聚合为一个值
func Reduce[Src any, R any](src []Src, reducer func(R, Src) R, initial R) R <span class="cov0" title="0">{
        return slice.Reduce(src, reducer, initial)
}</span>

// Filter 过滤元素，返回满足条件的新切片
func Filter[Src any](src []Src, predicate func(Src) bool) []Src <span class="cov0" title="0">{
        return slice.Filter(src, predicate)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package slice

import "github.com/sword-demon/vtool/internal/slice"

// Union 求两个切片的并集，返回去重的结果
func Union[Src comparable](src1, src2 []Src) []Src <span class="cov0" title="0">{
        return slice.Union(src1, src2)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
